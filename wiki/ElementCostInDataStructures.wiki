#summary This is the cost per element in major data structures offered by Java and Guava. It is generated by
#labels Featured
[http://goo.gl/L3wJ ElementCostOfDataStructures.java].

= Introduction =

Ever wondered what's the cost of adding an entry to a HashMap? Or a new element in a TreeSet? No more head-scratching, you can consult the following list and know very precisely the cost per elements in your data structures (using their default settings when not specified).

= Cost per element in various well-known Java/Guava data structures =
(*Note*: this test ran on a 64bit machine, so byte measurements should be roughly half on a 32bit.)
{{{
==========================================         Multimaps          ==========================================

                      HashMultimap_Worst :: Bytes = 352.48, Objects =  5.00 Refs = 29.06 Primitives = {int=5.0, float=1.0}
                LinkedHashMultimap_Worst :: Bytes = 616.97, Objects =  9.00 Refs = 51.12 Primitives = {int=7.0, boolean=1.0, float=1.0}
                      TreeMultimap_Worst :: Bytes = 232.00, Objects =  4.00 Refs = 18.00 Primitives = {int=2.0, boolean=2.0}
                 ArrayListMultimap_Worst :: Bytes = 208.48, Objects =  3.00 Refs = 16.06 Primitives = {int=3.0}
                 ImmutableMultimap_Worst :: Bytes =  96.45, Objects =  2.00 Refs =  8.06 Primitives = {}
             ImmutableListMultimap_Worst :: Bytes =  96.45, Objects =  2.00 Refs =  8.06 Primitives = {}
                      HashMultimap_Best  :: Bytes =  64.48, Objects =  1.00 Refs =  5.06 Primitives = {int=1.0}
                LinkedHashMultimap_Best  :: Bytes = 192.97, Objects =  3.00 Refs = 16.12 Primitives = {int=2.0}
                      TreeMultimap_Best  :: Bytes =  64.00, Objects =  1.00 Refs =  5.00 Primitives = {boolean=1.0}
                 ArrayListMultimap_Best  :: Bytes =  11.70, Objects =  0.00 Refs =  1.46 Primitives = {}
                 ImmutableMultimap_Best  :: Bytes =   8.00, Objects =  0.00 Refs =  1.00 Primitives = {}
             ImmutableListMultimap_Best  :: Bytes =   8.00, Objects =  0.00 Refs =  1.00 Primitives = {}

==========================================           Tables           ==========================================

                          HashBasedTable :: Bytes = 328.48, Objects =  4.00 Refs = 28.06 Primitives = {int=5.0, float=1.0}
                          TreeBasedTable :: Bytes = 208.00, Objects =  3.00 Refs = 17.00 Primitives = {int=2.0, boolean=2.0}

==========================================           BiMaps           ==========================================

                               HashBiMap :: Bytes = 128.97, Objects =  2.00 Refs = 10.12 Primitives = {int=2.0}
                          ImmutableBiMap :: Bytes = 128.90, Objects =  2.00 Refs = 12.11 Primitives = {}

==========================================            Misc            ==========================================

                             WeakHashMap :: Bytes =  88.48, Objects =  1.00 Refs =  8.06 Primitives = {int=1.0}
                              LinkedList :: Bytes =  40.00, Objects =  1.00 Refs =  3.00 Primitives = {}
                              ArrayDeque :: Bytes =   8.23, Objects =  0.00 Refs =  1.03 Primitives = {}
                           LinkedHashSet :: Bytes =  80.48, Objects =  1.00 Refs =  7.06 Primitives = {int=1.0}
                           PriorityQueue :: Bytes =   8.79, Objects =  0.00 Refs =  1.10 Primitives = {}
                   PriorityBlockingQueue :: Bytes =   8.79, Objects =  0.00 Refs =  1.10 Primitives = {}
                   ConcurrentSkipListSet :: Bytes =  60.21, Objects =  1.51 Refs =  4.52 Primitives = {int=0.0010080645161290322}
                    CopyOnWriteArrayList :: Bytes =   8.00, Objects =  0.00 Refs =  1.00 Primitives = {}
                     CopyOnWriteArraySet :: Bytes =   8.00, Objects =  0.00 Refs =  1.00 Primitives = {}
                              DelayQueue :: Bytes =   8.79, Objects =  0.00 Refs =  1.10 Primitives = {}
                     LinkedBlockingQueue :: Bytes =  32.00, Objects =  1.00 Refs =  2.00 Primitives = {}
                     LinkedBlockingDeque :: Bytes =  40.00, Objects =  1.00 Refs =  3.00 Primitives = {}
}}}

Some clarifications:
{{{HashMultimap_Worst}}} means that every key only maps to a single value. The huge memory cost you see is because by default a big hashtable is allocated per key - [http://guava-libraries.googlecode.com/svn/trunk/javadoc/com/google/common/collect/HashMultimap.html#create(int,%20int) you can fine-tune this size though]. Conversely, the "best" case is where a _single_ key maps to all values - there, the per-entry cost degenerates to the per-entry cost of a regular HashMap, for obvious reasons. The per-entry cost of a realistic HashMultimap will be somewhere (depending on the distribution of values in keys) between these two limits. Similarly, it should be obvious why {{{HashMultiset_Best}}} reports _zero_ cost in everything. 

Another curious observation: ArrayDeque does not resize at exactly the same thresholds as ArrayList does, so I had some tuning to do. The previous results were unlucky enough to show that an ArrayDeque had around _double_ the cost of an ArrayList, because the former resized but the latter did not, for the same amount of entries.

Another observation: Notice how HashBasedTable is slightly more compact than HashMultimap. (One object and one reference less for HashBasedTable). The difference is caused by HashMultimap using HashSet for the values of a key, while HashBasedTable uses HashMap for the columns of a row. But HashSet is just a wrapper over HashMap, adding the mentioned overhead.